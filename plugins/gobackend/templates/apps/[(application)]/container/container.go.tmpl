{{ $app := .App -}}

package container

import (
	"errors"
	"fmt"
	"log/slog"
	"reflect"
	"sync"

	"github.com/{{ $app | PackageName }}/config"
	"github.com/{{ $app | PackageName }}/log"
)

type Lifetime int

const (
	Transient Lifetime = iota
	Singleton
)

var (
	ErrNotRegistered      = errors.New("type not registered")
	ErrInvalidConstructor = errors.New("constructor must be a function")
	ErrBadReturnTypes     = errors.New("constructor must return (T) or (T, error)")
	ErrCycleDetected      = errors.New("dependency cycle detected")
)

type registration struct {
	lifetime    Lifetime
	constructor reflect.Value // func(...) (T[, error])
	resultType  reflect.Type  // the T that is produced/bound (may be an interface)
	once        sync.Once
	instance    reflect.Value
	initErr     error
}

type Container struct {
	mu            sync.RWMutex
	registrations map[reflect.Type]*registration
	cfg           config.Config
	logger        *slog.Logger
}

func New(logger *slog.Logger, cfg config.Config) *Container {
	c := &Container{
		registrations: make(map[reflect.Type]*registration),
	}

	RegisterSingleton[*slog.Logger](c, func() *slog.Logger { return logger })
	RegisterSingleton[config.Config](c, func() config.Config { return cfg })

	return c
}

func RegisterSingleton[T any](c *Container, constructor any) {
	Register[T](c, Singleton, constructor)
}

func Register[T any](c *Container, life Lifetime, constructor any) {
	t := typeOf[T]()
	c.registerForType(t, life, constructor)
}

func RegisterAs[TInterface any](c *Container, life Lifetime, constructor any) {
	iface := typeOf[TInterface]()
	if iface.Kind() != reflect.Interface {
		panic(fmt.Errorf("RegisterAs target must be an interface, got %v", iface))
	}
	c.registerForType(iface, life, constructor)
}

func Resolve[T any](c *Container) (T, error) {
	var zero T
	t := typeOf[T]()
	v, err := c.resolveType(t, newResolveState())
	if err != nil {
		return zero, err
	}
	if !v.Type().AssignableTo(t) {
		if v.CanConvert(t) {
			v = v.Convert(t)
		} else if t.Kind() == reflect.Interface && v.Type().Implements(t) {
			// ok
		} else {
			return zero, fmt.Errorf("resolved type %v is not assignable to %v", v.Type(), t)
		}
	}
	return v.Interface().(T), nil
}

func MustResolve[T any](c *Container) T {
	v, err := Resolve[T](c)
	if err != nil {
		panic(err)
	}
	return v
}

func (c *Container) registerForType(target reflect.Type, life Lifetime, constructor any) {
	cv := reflect.ValueOf(constructor)
	if cv.Kind() != reflect.Func {
		panic(ErrInvalidConstructor)
	}
	ct := cv.Type()
	if ct.NumOut() < 1 || ct.NumOut() > 2 {
		panic(ErrBadReturnTypes)
	}
	outT := ct.Out(0)
	if ct.NumOut() == 2 && ct.Out(1) != reflect.TypeOf((*error)(nil)).Elem() {
		panic(ErrBadReturnTypes)
	}
	if !outT.AssignableTo(target) {
		if !(outT.Kind() == reflect.Pointer && outT.Elem().AssignableTo(target)) && !outT.Implements(target) {
			if !(target.Kind() == reflect.Interface && (outT.Implements(target) || (outT.Kind() == reflect.Pointer && outT.Implements(target)))) {
				panic(fmt.Errorf("constructor returns %v which is not assignable to %v", outT, target))
			}
		}
	}

	c.mu.Lock()
	defer c.mu.Unlock()
	c.registrations[target] = &registration{
		lifetime:    life,
		constructor: cv,
		resultType:  target,
	}
}

func (c *Container) resolveType(target reflect.Type, st *resolveState) (reflect.Value, error) {
	c.mu.RLock()
	reg, ok := c.registrations[target]
	c.mu.RUnlock()
	if !ok {
		return reflect.Value{}, fmt.Errorf("%w: %v", ErrNotRegistered, target)
	}

	switch reg.lifetime {
	case Singleton:
		reg.once.Do(func() {
			reg.instance, reg.initErr = c.invokeConstructor(reg.constructor, st)
		})
		return reg.instance, reg.initErr
	case Transient:
		return c.invokeConstructor(reg.constructor, st)
	default:
		return reflect.Value{}, fmt.Errorf("unknown lifetime for %v", target)
	}
}

func (c *Container) invokeConstructor(ctor reflect.Value, st *resolveState) (reflect.Value, error) {
	ct := ctor.Type()
	argc := ct.NumIn()
	args := make([]reflect.Value, argc)

	ctorKey := ctor.Pointer()
	if st.inProgress[ctorKey] {
		return reflect.Value{}, ErrCycleDetected
	}
	st.inProgress[ctorKey] = true
	defer func() { delete(st.inProgress, ctorKey) }()

	for i := range argc {
		pt := ct.In(i)
		if pt == reflect.TypeOf((*Container)(nil)) {
			args[i] = reflect.ValueOf(c)
			continue
		}
		dep, err := c.resolveType(pt, st)
		if err != nil {
			return reflect.Value{}, fmt.Errorf("resolving %v for %v: %w", pt, ctor.Type(), err)
		}
		args[i] = dep
	}
	out := ctor.Call(args)
	if len(out) == 1 {
		return out[0], nil
	}
	if !out[1].IsNil() {
		return reflect.Value{}, out[1].Interface().(error)
	}
	return out[0], nil
}

func (c *Container) GetLogger(component string) *slog.Logger {
	logger := MustResolve[*slog.Logger](c)
	return logger.With(log.WithComponent(component))
}

func (c *Container) GetConfig() config.Config {
	return MustResolve[config.Config](c)
}

type resolveState struct {
	inProgress map[uintptr]bool
}

func newResolveState() *resolveState {
	return &resolveState{inProgress: make(map[uintptr]bool)}
}

func typeOf[T any]() reflect.Type {
	return reflect.TypeOf((*T)(nil)).Elem()
}
